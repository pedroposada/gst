<?php

/**
 * Create a cropped image using the thumbnail as the focus point.
 * 
 * This function is meant to be used when ever an image from an article
 * or blog needs to be displayed. It checks if a new cropped image needs
 * to be created or if an old image needs to be updated.
 *
 * @param $entity
 *     A field collection entity from field_mediacollection which MUST contain the following information:
 *     - 'field_thumbnaildata': The markup that was generated by Pedro's cropper tool.
 *     - 'field_media': The file entity itself.
 * @param $image_style
 *     The target image style to use when creating the image.
 *
 * @return array
 *     An array of the $crop_data or FALSE if fails.
 */
function gs_helper_focus_crop_image(&$field_mediacollection_entity, $image_style) {
  // Check if crucial thumbnail markup data is available.
  if (!empty($field_mediacollection_entity->field_thumbnaildata[LANGUAGE_NONE][0]['value'])) {
    $thumbHTML = filter_dom_load($field_mediacollection_entity->field_thumbnaildata[LANGUAGE_NONE][0]['value']);
    $thumb = $thumbHTML->getElementsByTagName('img')->item(0);
    $thumb_styles = explode(';', $thumb->getAttribute('style'));
    $crop_data = $original_crop_data = $ratio = array();
    
    // Check if crop data is available.
    if (isset($field_mediacollection_entity->field_crop_data[LANGUAGE_NONE][0]['value'])) {
      $original_crop_data = unserialize($field_mediacollection_entity->field_crop_data[LANGUAGE_NONE][0]['value']);
      // Account for old crop data that only held a string.
      if (is_string($original_crop_data['uri'])) {
        $original_crop_data['uri'] = array('article_sidebar_thumbnail' => $original_crop_data['uri']);
      }
    }
    
    // Pull the values we needed from the inline styles.
    foreach ($thumb_styles as $style) {
      if(strstr($style, 'width')) {
        if (preg_match('/\d+/', $style, $matches)) {
          $crop_data['width'] = (int) $matches[0];
        }
      }
      elseif (strstr($style, 'height')) {
        if (preg_match('/\d+/', $style, $matches)) {
          $crop_data['height'] = (int) $matches[0];
        }
      }
      elseif (strstr($style, 'margin-left')) {
        if (preg_match('/\d+/', $style, $matches)) {
          $crop_data['x'] = (int) $matches[0];
        }
      }
      elseif (strstr($style, 'margin-top')) {
        if (preg_match('/\d+/', $style, $matches)) {
          $crop_data['y'] = (int) $matches[0];
        }
      }
    }
    
    // Assign the same uri values to make it easier to compare.
    if (isset($original_crop_data['uri'])) {
      $crop_data['uri'] = $original_crop_data['uri'];
    }
    
    // Check if an image needs to be generated.
    if (($crop_data === $original_crop_data) && array_key_exists($image_style, $original_crop_data['uri'])) {
      return $original_crop_data;
    }
    
    if($image_uri = file_load($field_mediacollection_entity->field_media[LANGUAGE_NONE][0]['fid'])->uri) {
      if ($image_file = image_load($image_uri)) {
        $image_source_data = $image_target_data = array(
          'width' => (int) $image_file->info['width'],
          'height' => (int) $image_file->info['height'],
          'ratio' => $image_file->info['width']/$image_file->info['height'],
        );
        
        // Applies all of an image style's effects to $image_style_dimensions and
        // determines the dimensions of the final styled image.
        image_style_transform_dimensions($image_style, $image_target_data);
        $image_target_data['ratio'] = $image_target_data['width'] / $image_target_data['height'];
        
        // Calculate the ratio differences of the thumbnail data and source data.
        $ratio = array(
          'width' => $image_source_data['width'] / $crop_data['width'],
          'height' => $image_source_data['height'] / $crop_data['height'],
        );
        
        // Calculate the focus point of the source image by using the ratio data as reference.
        $focus_point = array(
          'x' => (int) round(($crop_data['x'] * $ratio['width']) + ((160 * $ratio['width'])/2)),
          'y' => (int) round(($crop_data['y'] * $ratio['height']) + ((120 * $ratio['height'])/2)),
        );
        
        // Calculate the crop frame of the source image by using the ratio data as reference.
        $image_source_data['crop_width'] = (int) round($image_target_data['width'] * $ratio['width']);
        $image_source_data['crop_height'] = (int) round($image_target_data['height'] * $ratio['height']);
        
        // Adjust the crop frame if it is cropping a larger area than the dimensions of the source image.
        if ($image_source_data['ratio'] < $image_target_data['ratio']) {
          if ($image_source_data['crop_width'] > $image_source_data['width']) {
            $image_source_data['crop_width'] = $image_source_data['width'];
            $image_source_data['crop_height'] = (int) round($image_source_data['crop_width'] / $image_target_data['ratio']);
          }
        }
        else {
          if ($image_source_data['crop_height'] > $image_source_data['height']) {
            $image_source_data['crop_height'] = $image_source_data['height'];
            $image_source_data['crop_width'] = (int) round($image_source_data['crop_height'] * $image_target_data['ratio']);
          }
        }
        
        // Determine the point where the cropping should start.
        $crop_point = gs_helper_get_crop_point($image_source_data, $focus_point);
        
        // Crop the image file
        if (!image_crop($image_file, $crop_point['x'], $crop_point['y'], $image_source_data['crop_width'], $image_source_data['crop_height'])) {
          watchdog('gs_helper.images.inc', 'Image crop failed using the %toolkit toolkit on %path', array('%toolkit' => $image_file->toolkit, '%path' => $image_file->source), WATCHDOG_ERROR);
        }
        
        // Resize the image to target size.
        if (!image_resize($image_file, $image_target_data['width'], $image_target_data['height'])) {
          watchdog('gs_helper.images.inc', 'Image resize failed using the %toolkit toolkit on %path', array('%toolkit' => $image_file->toolkit, '%path' => $image_file->source), WATCHDOG_ERROR);
        }
        
        // Save the processed image to the image style's directory.
        $destination_uri = $crop_data['uri'][$image_style] = image_style_path($image_style, $image_uri);
        image_save($image_file, $destination_uri);
        
        /*dsm(array(
          'ratio' => $ratio,
          'image_source_data' => $image_source_data,
          'image_target_data' => $image_target_data,
          'focus_point' => $focus_point,
          'crop_point' => $crop_point,
          'crop_data' => $crop_data,
          'original_crop_data' => $original_crop_data,
        ));*/
        
        return $crop_data;
      }
    }
  }
  
  return FALSE;
}

/**
 * Calculate the coordinate where the cropping should start.
 *
 * @param $image_source_data
 *     An array which MUST contain the following information about the original source image:
 *     - 'width': The width of the original source image in pixels.
 *     - 'height': The height of the original source image in pixels.
 *     - 'crop_width': The width of the crop area in pixels.
 *     - 'crop_height': The height of the crop area in pixels.
 * @param $focus_point
 *     An array with coordinates 'x' and 'y', where the crop should be focused.
 *
 * @return array
 *     An array of the results or default if fails.
 */
function gs_helper_get_crop_point($image_source_data, $focus_point) {
  $x = $y = 0;
  
  $x = (int) round($focus_point['x'] - ($image_source_data['crop_width']/2));
  $y = (int) round($focus_point['y'] - ($image_source_data['crop_height']/2));
  
  // Check if the cropped image is framing anything outside of the original image's
  // dimensions and move the crop point to accomodate.
  $combined = array(
    'width' => $x + $image_source_data['crop_width'],
    'height' => $y + $image_source_data['crop_height'],
  );
  if ($combined['width'] > $image_source_data['width']) {
    $x = $x - ($combined['width'] - $image_source_data['width']);
  }
  if ($combined['height'] > $image_source_data['height']) {
    $y = $y - ($combined['height'] - $image_source_data['height']);
  }
  
  return array(
    'x' => ($x < 0) ? 0 : $x,
    'y' => ($y < 0) ? 0 : $y,
  );
}